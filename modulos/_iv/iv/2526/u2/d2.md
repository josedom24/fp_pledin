---
title: "Docker: Creando contenedores demonios
---

En esta ocasión usamos la opción `-d` (detach) del comando `run`, para que la ejecución del comando en el contenedor se haga en segundo plano.

## Ejemplo 1: Creando un contenedor con un servidor web

Tenemos muchas imágenes en el registro público **docker hub**, por ejemplo podemos crear un servidor web con apache 2.4:

```bash
$ docker run -d --name my-apache-app -p 8080:80 httpd:2.4
```

Vemos que el contenedor se está ejecutando, además con la opción `-p` mapeamos un puerto del equipo donde tenemos instalado el docker, con un puerto del contenedor: Si accedemos a la ip del ordenador que tiene instalado docker al primer puerto indicado, se redigirá la petición a la ip del contenedor al segundo puerto indicado. **Nunca utilizamos directamente la ip del contenedor para acceder a él**. Para probarlo accede desde un navegador a **la ip del servidor con docker.

Para acceder al log del contenedor podemos ejecutar: `docker logs my-apache-app` o para visualizarlo en tiempo real la opción `logs -f`.

Podemos parar el contenedor y borrarlo con las siguientes instrucciones:

```bash
$ docker stop my-apache-app`
$ docker rm my-apache-app`
```

O ejecutando: `docker rm -f my-apache-app`.

### Modificación del contenido servidor por el servidor web

Si consultamos la documentación de la imagen [`httpd`](https://hub.docker.com/_/httpd) en el registro docker Hub, podemos determinar que le servidor web que se ejecuta en el contenedor guardar sus ficheros (directorio *DocumentRoot*) en `/usr/local/apache2/htdocs/`. Vamos a crear un nu nuevo fichero `index.html` en ese directorio.

Lo podemos hacer de varias formas:

* Accediendo de forma interactiva al contenedor y haciendo la modificación:

    ```bash
    $ docker exec -it my-apache-app bash

    root@cf3cd01a4993:/usr/local/apache2# cd /usr/local/apache2/htdocs/
    root@cf3cd01a4993:/usr/local/apache2/htdocs# echo "<h1>Curso Docker</h1>" > index.html
    root@cf3cd01a4993:/usr/local/apache2/htdocs# exit
    ```

* Ejecutando directamente el comando de creación del fichero `index.html` en el contenedor:

    ```bash
    $ docker exec my-apache-app bash -c 'echo "<h1>Curso Docker</h1>" > /usr/local/apache2/htdocs/index.html'
    ```

* Copiando un fichero `index.html` dento del contenedor:

    ```
    $ echo "<h1>Curso Docker</h1>" > index.html
    $ docker cp index.html  my-apache-app:/usr/local/apache2/htdocs/
    ``

Independientemente de cómo hayamos creado el fichero, podemos volver a acceder al servidor web y comprobar que efectivamente hemos cambiado el contenido del `index.html`.

## Ejemplo 2: Configuración de un contenedor con la imagen mariadb

En ocasiones es obligatorio el inicializar alguna variable de entorno para que el contenedor pueda ser ejecutado. Si miramos la [documentación](https://hub.docker.com/_/mariadb) en Docker Hub de la imagen mariadb, observamos que podemos definir algunas variables de entorno para la creación y configuración del contenedor (por ejemplo: `MARIADB_DATABASE`,`MARIADB_USER`, `MARIADB_PASSWORD`,...). Pero hay una que la tenemos que indicar de forma obligatoria, la contraseña del usuario `root` (`MARIADB_ROOT_PASSWORD`), por lo tanto:

```bash
$ docker run -d --name some-mariadb -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED                STATUS              PORTS               NAMES
9c3effd891e3        mariadb             "docker-entrypoint.s…"   8 seconds ago       Up 7   seconds        3306/tcp            some-mariadb
```

Podemos ver que se ha creado una variable de entorno:

```bash
$ docker exec -it some-mariadb env
...
MARIADB_ROOT_PASSWORD=my-secret-pw
...
```

Y para acceder podemos ejecutar:

```bash
$ docker exec -it some-mariadb bash                                  
root@9c3effd891e3:/# mariadb -u root -p"$MARIADB_ROOT_PASSWORD" 
...

MariaDB [(none)]> 
```
Otra forma de hacerlo sería:

```bash
$ docker exec -it some-mariadb mariadb -u root -p
Enter password: 
...
MariaDB [(none)]> 
```

No hemos usado el parámetro `-p` para mapear los puertos de MariaDB, porque norlmanete no accedemos a las bases de datos desde el exterior.

{% capture notice-text %}
## Ejercicio

1. Realiza el ejemplo 1 y el ejemplo 2 que acabamos de ver.

{% endcapture %}<div class="notice--warning">{{ notice-text | markdownify }}</div>



## Configuración de contenedores con variables de entorno

Más adelante veremos que al crear un contenedor que necesita alguna configuración específica, lo que vamos a hacer es crear variables de entorno en el contenedor, para que el proceso que inicializa el contenedor pueda realizar dicha configuración.

Para crear una variable de entorno al crear un contenedor usamos el flag `-e` o `--env`:

```bash
$ docker run -it --name contenedor5 -e USUARIO=prueba ubuntu bash
root@91e81200c633:/# echo $USUARIO
prueba
```

{% capture notice-text %}
## Ejercicio

1. Crea un contenedor con la aplicación Nextcloud, mirando la [documentación en docker Hub](https://hub.docker.com/_/nextcloud). Utiliza una variable de entorno para personalizar el nombre de la base de datos sqlite que va a utilizar.

{% endcapture %}<div class="notice--warning">{{ notice-text | markdownify }}</div>