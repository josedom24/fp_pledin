---
title: "Acceso a las aplicaciones: Services"
---

## Services

* **Servicios (Services)**: permiten acceder a las aplicaciones desplegadas en el clúster.
* **Definición de Service**:

  * Abstracción para acceder a un conjunto de Pods creados a partir de un Deployment.
  * Representa una aplicación o parte de ella (web, base de datos, etc.).
* **Acceso a los Pods**:

  * Cada Pod tiene una IP propia no accesible directamente.
  * El Service proporciona una IP virtual (**CLUSTER-IP**) y un nombre estable.
* **Tipos de acceso**:

  * Desde otros Pods del clúster.
  * Desde el exterior, mediante la asignación de un puerto.
* **Ejemplo de uso**:

  * Aplicación con Service de servidor web (accesible desde el exterior).
  * Service de base de datos accesible solo desde el servidor web.
* **Balanceo de carga**:

  * Si hay varios Pods, el Service distribuye las peticiones (Round Robin).
* **Resolución de nombres (DNS)**:

  * El clúster dispone de un servicio DNS.
  * Al crear un Service, su nombre se asocia a su CLUSTER-IP.
* **Servicios sin estado (stateless)**:

  * Las peticiones son independientes.
  * Escalables fácilmente (ej. servidor web estático).
  * Requieren que los datos sean compartidos entre Pods.
* **Servicios con estado (stateful)**:

  * Las peticiones pueden depender de interacciones previas.
  * No se pueden escalar sin control adicional.
  * Necesitan mecanismos para mantener coherencia de datos (ej. bases de datos).

## Tipos de services

### ClusterIP

Solo se permite el acceso interno a un Service de este tipo. Es decir, si tenemos un despliegue con una aplicación a la que no es necesario acceder desde el exterior, crearemos un Service de este tipo para que otras aplicaciones puedan acceder a ella (por ejemplo, una base de datos). Es el tipo por defecto. Si deseamos seguir accediendo desde el exterior, para hacer pruebas durante la fase de desarrollo podemos seguir utilizando la instrucción `kubectl port-forward`.

![clusterip](img/clusterip.png)

Veamos el ejemplo:

1. Necesitamos que los Pods de Wordpress accedan al Pod del MySQL.
2. La IP que ha tomado el Pod de MySQL (`172.25.3.5`) es inaccesible desde los Pods de Wordpress.
3. Por lo tanto hemos creado un Service de tipo ClusterIP, que ha obtenido una ip virtual (`192.168.3.5`) y expone el puerto de MySQL 3306.
4. Esta IP sí es accesible desde los Pods de Wordpress.
5. Al acceder a esta IP se balanceará la carga entre los Pods de MySQL (en el ejemplo sólo tenemos uno).
6. Además en el Wordpress no necesitamos configurar la IP virtual del Service que hemos creado, ya que disponemos de un servidor DNS que resuelve el nombre del Service `mysql` en la dirección virtual del Service (`192.168.3.5`). Por lo tanto en la configuración de Wordpress pondremos el nombre `mysql` como host del servidor de base de datos al que debe acceder.

### NodePort

Abre un puerto, para que el Service sea accesible desde el exterior. Por defecto el puerto generado está en el rango de 30000:40000. Para acceder usamos la ip del servidor master del cluster y el puerto asignado.

![nodeport](img/nodeport.png)

Veamos el ejemplo:

1. Necesitamos que los Pods de Wordpress sean accesibles desde el exterior, para que podamos acceder a la aplicación.
2. La IP que han tomado los Pods de Wordpress (`172.25.3.3`, ...) no son accesibles desde el exterior. Además comprobamos que estos Pods están ofreciendo el servicio en el puerto 8080.
3. Por lo tanto, hemos creado un Service de tipo NodePort que ha obtenido una IP virtual (`192.168.3.4`) y expone el puerto 80.
4. Al acceder a esta IP al puerto 80 se balanceará la carga entre los Pods de Wordpress, accediendo a las IPs de los Pods de Wordpress al puerto 8080.
5. El Service NodePort ha asignado un puerto de acceso aleatorio (entre el 30000 - 40000) que nos permite acceder a la aplicación mediante la IP del nodo master. En el ejemplo si accedemos a `10.0.2.4:30453` estaremos accediendo al Service que nos permitirá acceder a la aplicación.

### LoadBalancer

Este tipo sólo está soportado en servicios de cloud público (GKE, AKS o AWS). El proveedor asignará un recurso de balanceo de carga para el acceso a los Services. Si usamos un cloud privado como OpenStack, necesitaremos un plugin para configurar el funcionamiento. Este tipo de Service no lo vamos a utilizar en el presente curso.

![loadbalancer](img/loadbalancer.png)

Como vemos en el ejemplo, el cloud de infraestructura donde tengamos instalado el cluster nos ofrecerá un recurso *balanceador de carga* con una IP accesible desde el exterior que nos permitirá acceder a la aplicación directamente.

## Describiendo Services

### Services NodePort

Suponemos que tenemos desplegado nginx usando el fichero yaml: `nginx-deployment.yaml`:

    kubectl apply -f nginx-deployment.yaml

Por lo tanto tenemos dos Pods ofreciendo el servidor web nginx, a los que queremos acceder desde el exterior y que se balancee la carga entre ellos.

Aunque podríamos crear un recurso Service desde la línea de comandos:

    kubectl expose deployment/nginx --port=80 --type=NodePort

Normalmente lo que hacemos es describir las características del Service en un fichero yaml `nginx-srv.yaml`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  type: NodePort
  ports:
  - name: service-http
    port: 80
    targetPort: http
  selector:
    app: nginx
```
Veamos la descripción:

* Vamos a crear un recurso Service (parámetro `kind`) y lo nombramos como `nginx` (parámetro `name`). Este nombre será importante para la resolución dns.
* En la especificación del recurso indicamos el tipo de Service (parámetro `type`).
* A continuación, definimos el puerto por el que va a ofrecer el Service y lo nombramos (dentro del apartado `port`: el parámetro `port` y el parámetro `name`). Además, debemos indicar el puerto en el que los Pods están ofreciendo el Service (parámetro `targetPort`), en este caso, hemos usado el nombre del puerto (`http`) que indicamos en el recurso Deployment:

```yaml
   ...
   ports:
    - name: http
      containerPort: 80
   ...
```
* Por ultimo, seleccionamos los Pods a los que vamos acceder y vamos a balancear la carga seleccionando los Pods por medio de sus etiquetas (parámetro `selector`).

**Nota: La definición de un Service de tipo ClusterIP sería exactamente igual, pero cambiando el parámetro `type`.**

### Vídeo

[https://www.youtube.com/watch?v=kI2rZmqA7TI](https://www.youtube.com/watch?v=kI2rZmqA7TI)

## Gestionando los Services

### Service de tipo NodePort

Para aprender cómo gestionamos los Services, vamos a trabajar con el Deployment de nginx ([`nginx-deployment.yaml`](../modulo5/files/nginx-deployment.yaml)) y el Service NodePort ([`nginx-srv.yaml`](files/nginx-srv.yaml)) para acceder a los Pods de este despliegue desde el exterior.

#### Creamos el Deployment

El primer paso sería crear el Deployment de nginx:

    kubectl apply -f nginx-deployment.yaml

#### Creamos el Service

A continuación vamos a crear el Service de tipo NodePort que nos permitirá acceder al servidor nginx.

    kubectl apply -f nginx-srv.yaml

Para ver los Services que tenemos creado:

    kubectl get services

Recuerda que si usamos `kubectl get all` también se mostrarán los Services.

Antes de acceder a la aplicación podemos ver la información más detallada del Service que acabamos de crear:

    kubectl describe service/nginx
    Name:                     nginx
    ...
    Selector:                 app=nginx
    Type:                     NodePort
    ...
    IP:                       10.110.81.74
    Port:                     service-http  80/TCP
    TargetPort:               http/TCP
    NodePort:                 service-http  32717/TCP
    Endpoints:                172.17.0.3:80,172.17.0.4:80
    ...

Podemos ver la etiqueta de los Pods a los que accede (`Selector`). El tipo de Service (`Type`). La IP virtual que ha tomado (CLUSTER-IP) y que es accesible desde el cluster (`IP`). El puerto por el que ofrece el Service (`Port`). El puerto de los Pods a los que redirige el tráfico (`TargetPort`). Al ser un service de tipo NodePort nos da información del puerto que se asignado para acceder a la aplicación (`NodePort`). Y por último, podemos ver las IPs de los Pods que ha seleccionado y sobre los que balanceará la carga (`Endpoints`).

#### Accediendo a la aplicación

Vemos el Service que hemos creado:

    kubectl get services
    ...
    nginx        NodePort    10.110.81.74   <none>        80:32717/TCP   32s

Observamos que se ha asignado el puerto 32717 para el acceso, por lo tanto si desde un navegador accedemos a la IP del nodo master y a este puerto podremos ver la aplicación.

¿Cómo sé la dirección ip del nodo master del cluster minikube? Podemos ejecutar:

    minikube ip
    192.168.39.222

Y ya podemos acceder desde un navegador web a la URL `http://192.168.39.222:32717`.

### Service ClusterIP

En esta ocasión vamos a desplegar una base de datos MariaDB. En este caso no vamos a necesitar acceder a la base de datos desde el exterior, pero necesitamos que los Pods de otro despliegue puedan acceder a ella. Por lo tanto vamos a crear un Service de tipo ClusterIP.

Para el despliegue de MariaDB vamos a usar el fichero [`mariadb-deployment.yaml`](files/mariadb-deployment.yaml). Puedes comprobar que en la definición del contenedor hemos añadido la sección `env` que nos permite establecer variables de entorno para configurar el contenedor (los estudiaremos en el siguiente módulo).

Para la creación del Service utilizamos el fichero [`mariadb-srv.yaml`](files/mariadb-srv.yaml).

Para la creación del Deployment y el Service vamos ejecutando las siguientes instrucciones:

    kubectl apply -f mariadb-deployment.yaml
    kubectl apply -f mariadb-srv.yaml

Comprobamos el Service creado:

    kubectl get services
    mariadb      ClusterIP   10.106.60.233   <none>        3306/TCP       2m22s

    kubectl describe service/mariadb
    Name:              mariadb
    ...
    Selector:          app=mariadb
    Type:              ClusterIP
    ...
    IP:                10.106.60.233
    Port:              service-bd  3306/TCP
    TargetPort:        db-port/TCP
    Endpoints:         172.17.0.5:3306
    ...

Podemos comprobar que no se ha mapeado un puerto aleatorio para que accedamos usando la IP del nodo master. Los Pods que accedan a la IP 10.106.60.233 o al nombre `mariadb` y al puerto 3306 estarán accediendo al Pod (172.17.0.5:3306) del despliegue de mariadb.

### Eliminando los servicios

Por ejemplo para borrar el servicio `mariadb`, ejecutaríamos:

    kubectl delete service mariadb

### Vídeo

[https://www.youtube.com/watch?v=UAaBzXG13XU](https://www.youtube.com/watch?v=UAaBzXG13XU)



{% capture notice-text %}

## Ejercicio 1: Despliegue y acceso de la aplicación GuestBook

Una vez que tenemos creado el despliegue de la aplicación GuestBook, que realizamos en el anterioor taller, vamos a crear los Services correspondientes para acceder a ella:

### Service para acceder a la aplicación

El primer Service que vamos a crear nos va a permitir acceder a la aplicación GuestBook desde el exterior, para ello crea un fichero yaml con la definición del Service a partir de la siguiente plantilla:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: guestbook
  labels:
    app: guestbook
    tier: frontend
spec:
  type: 
  ports:
  - port: 
    targetPort: 
  selector:
    app: guestbook
    tier: frontend
```

Tienes que poner el tipo del Service, el puerto del servicio será el 80 y el nombre del puerto de la aplicación que hemos asignado en el Deployment es `http-server`.

Realiza los siguientes pasos:

1. Elabora el fichero yaml con la definición del Service, y créalo.
2. Comprueba el puerto que le han asignado al Service para acceder desde el exterior.
3. Accede a la ip del nodo master y al puerto asignado desde un navegador web para ver la aplicación.
4. Responde la siguiente pregunta: ¿Por qué aparece el mensaje de error: **Waiting for database connection...**?

### Service para acceder a la base de datos

A continuación vamos a crear el Service para acceder a la base de datos. Vamos a crear el fichero yaml para su definición a partir de la siguiente plantilla:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: redis
  labels:
    app: redis
    tier: backend
spec:
  type: 
  ports:
  - port: 
    targetPort: 
  selector:
    app: redis
    tier: backend
```
Tienes que poner el tipo del Service, el puerto del servicio será el 6379 y el nombre del puerto de la base de datos que hemos asignado en el Deployment es `redis-server`. **Nota: No cambies el nombre del Service, ya que la aplicación guestbook va a acceder por defecto a la base de datos usando el nombre `redis`**.

Realiza los siguientes pasos:

1. Elabora el fichero yaml con la definición del Service, y créalo.
2. Lista los Services que has creado.
3. Accede a la ip del nodo master y al puerto asignado desde un navegador web para ver la aplicación. Comprueba que funciona sin ningún problema.


{% endcapture %}<div class="notice--warning">{{ notice-text | markdownify }}</div>

