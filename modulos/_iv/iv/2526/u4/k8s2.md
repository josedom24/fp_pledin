---
title: Trabajando con Pods
---

## Pod


* **Pod**:

  * Es la **unidad más pequeña de ejecución en Kubernetes**.
  * Un Pod es una **envoltura** que contiene **uno o varios contenedores** (habitualmente uno solo).
  * Los contenedores de un Pod:
    * Comparten **almacenamiento**.
    * Comparten una **única dirección IP**.
* **Naturaleza efímera de los Pods**:
  * Los Pods pueden **crearse, detenerse o destruirse** con facilidad.
  * Kubernetes puede crear **nuevos Pods para sustituir a los anteriores**.
  * La información almacenada en un Pod **no es persistente** por defecto.
  * Para conservar datos es necesario usar **mecanismos de almacenamiento externos**.
  * Aunque Kubernetes orquesta contenedores, la **unidad mínima real es el Pod**, no el contenedor.
* **Relación Pod–contenedor**:
  * Siguiendo el principio de **un proceso por contenedor**:
    * Lo más habitual es un **Pod con un solo contenedor**.
  * En casos especiales:
    * Un Pod puede contener **varios contenedores**, cada uno ejecutando un proceso.
    * Estos contenedores están **fuertemente acoplados** y se comportan como procesos en un mismo sistema.
* **Motivación de la capa Pod**:
  * Kubernetes puede trabajar con **distintos runtimes de contenedores** (Docker, containerd, CRI-O, etc.).
  * El Pod actúa como **capa de abstracción**, independiente del runtime.
  * Permite definir información adicional como:
    * **Políticas de reinicio**.
    * **Readiness probes** (comprobación de inicialización).
    * **Liveness probes** (comprobación de estado).
* **Pod con un solo contenedor**:

  * Es el caso más habitual.
  * Ejecuta un **único proceso**.
  * El Pod existe mientras el proceso del contenedor está en ejecución.
  * Ejemplos típicos:
    * Servidor web en modo demonio.
    * Servidor de aplicaciones Java.
    * Tareas programadas.
    * Servidor DNS.
* **Pod multicontenedor**:
  * Se utiliza cuando hay **procesos fuertemente acoplados**.
  * Cada proceso se ejecuta en su **propio contenedor**.
  * Los contenedores:
    * Comparten almacenamiento si es necesario.
    * Comparten una misma IP.
  * Ejemplo típico:
    * Nginx + PHP-FPM en un mismo Pod.

## Describiendo un Pod

Es posible crear un Pod directamente (lo que se denomina utilización imperativa) mediante `kubectl`:

    kubectl run pod-nginx --image=nginx

De esta forma se crea un Pod con un contenedor que utiliza la imagen `nginx:latest` (no hemos especificado una versión) del registro que esté definido por defecto en el cluster de Kubernetes, se asigna una dirección IP y se lanza en uno de los nodos del cluster. 

Un Pod tiene otros muchos parámetros asociados, que en este caso quedarán sin definir o Kubernetes asumirá los valores por defecto. Sin embargo es mucho más habitual trabajar con los objetos de Kubernetes de manera declarativa, definiendo los objetos de forma detallada a través de un fichero en formato YAML. De esta forma tenemos un fichero con la definición del objeto que hemos lanzado y podemos utilizar en otro momento exactamente la misma definición o podemos ir modificándola y aplicando los cambios cuando sea conveniente. 

Un ejemplo podría ser el contenido del fichero `pod.yaml`:

```yaml
apiVersion: v1 # required
kind: Pod # required
metadata: # required
 name: pod-nginx # required
 labels:
   app: nginx
   service: web
spec: # required
 containers:
   - image: nginx:1.16
     name: contenedor-nginx
     imagePullPolicy: Always
```

Veamos cada uno de los parámetros que hemos definido:

* `apiVersion: v1`: La versión de la API que vamos a usar.
* `kind: Pod`: La clase de recurso que estamos definiendo.
* `metadata`: Información que nos permite identificar unívocamente el recurso:
    * `name`: Nombre del pod
    * `labels`: Las [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) nos permiten etiquetar los recursos de Kubernetes (por ejemplo un pod) con información del tipo clave/valor.
* `spec`: Definimos las características del recurso. En el caso de un Pod indicamos los contenedores que van a formar el Pod (sección `containers`), en este caso sólo uno.
    * `image`: La imagen desde la que se va a crear el contenedor
    * `name`: Nombre del contenedor.
    * `imagePullPolicy`: Las imágenes se guardan en un registro interno. Se pueden utilizar registros públicos (google o docker hub son los más usados) y registros privados. La política por defecto es `IfNotPresent`, que se baja la imagen si no está en el registro interno. Si queremos forzar la descarga desde el repositorio externo, tendremos que indicar `imagePullPolicy:Always`.

### Vídeo

[https://www.youtube.com/watch?v=zMkXnENOBBc](https://www.youtube.com/watch?v=zMkXnENOBBc)

## Gestionando los Pods

Podemos crear directamente el Pod desde el fichero yaml:

    kubectl create -f pod.yaml

Y podemos ver el estado en el que se encuentra y si está o no listo:

    kubectl get pods

Si queremos ver más información sobre los Pods, como por ejemplo, saber en qué nodo del cluster se está ejecutando:

    kubectl get pod -o wide

Para obtener información más detallada del Pod (equivalente al inspect de docker):

    kubectl describe pod pod-nginx

Normalmente no se interactúa directamente con el Pod a través de una shell, pero sí se obtienen directamente los logs al igual que se hace en docker:

    kubectl logs pod-nginx

En el caso poco habitual de que queramos ejecutar alguna orden adicional en el Pod, podemos utilizar el comando `exec`, por ejemplo, en el caso particular de que queremos abrir una shell de forma
interactiva:

    kubectl exec -it pod-nginx -- /bin/bash

Podemos acceder a la aplicación, redirigiendo un puerto de localhost al puerto de la aplicación:

    kubectl port-forward pod-nginx 8080:80

Y accedemos al servidor web en la url http://localhost:8080.

**NOTA**: Esta no es la forma con la que accedemos a las aplicaciones en Kubernetes. Para el acceso a las aplicaciones usaremos un recurso llamado Service. Con la anterior instrucción lo que estamos haciendo es una redirección desde localhost el puerto 8080 al puerto 80 del Pod y es útil para pequeñas pruebas de funcionamiento, nunca para acceso real a un servicio.
**NOTA2**: El `port-forward` no es igual a la redirección de puertos de docker, ya que en este caso la redirección de puertos se hace en el equipo que ejecuta `kubectl`, no en el equipo que ejecuta los Pods o
los contenedores.

Y por último, eliminamos el Pod mediante:

    kubectl delete pod pod-nginx

### Vídeo

[https://www.youtube.com/watch?v=OA0OheCtrXo](https://www.youtube.com/watch?v=OA0OheCtrXo)

{% capture notice-text %}
## Ejercicio

Vamos a crear nuestro primer Pod, y para ellos vamos a desplegar una imagen que nos ofrece un servidor web con una página estática. Para ello realiza los siguientes pasos:

1. Crea un fichero yaml con la descripción del recurso Pod, teniendo en cuenta los siguientes aspectos:
    * Indica nombres distintos para el Pod y para el contenedor.
    * La imagen que debes desplegar es `iesgn/test_web:latest`.
    * Indica una etiqueta en la descripción del Pod.
2. Crea el Pod.
3. Comprueba que el Pod se ha creado y está corriendo.
4. Obtén información detallada del Pod creado.
5. Accede de forma interactiva al Pod y comprueba los ficheros que están en el DocumentRoot (`usr/local/apache2/htdocs/`).
6. Crea una redirección con `kubectl port-forward` utilizando el puerto de localhost 8888 y sabiendo que el Pod ofrece el servicio en el puerto 80. Accede a la aplicación desde un navegador.
7. Muestra los logs del Pod y comprueba que se visualizan los logs de los accesos que hemos realizado en el punto anterior.
8. Elimina el Pod, y comprueba que ha sido eliminado.

Por último si quieres practicar con un pod multicontendor puedes realizar el siguiente [ejercicio](https://fp.josedomingo.org/sri/8_k8s/ejercicio2.html).ç

{% endcapture %}<div class="notice--warning">{{ notice-text | markdownify }}</div>

